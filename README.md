# üß† Java DSA Roadmap: Beginner to Advanced

---

## 1. üî§ Basics of Java
1.1 Java Syntax & Structure  
1.2 Variables, Data Types  
1.3 Operators and Expressions  
1.4 Loops (for, while, do-while)  
1.5 Conditional Statements (if, switch)  
1.6 Functions and Methods  
1.7 Arrays and String Basics  
1.8 Object-Oriented Programming  
1.9 Java Collections Framework (List, Set, Map)  
1.10 Exception Handling  

---

## 2. üì¶ Arrays & Strings
2.1 Introduction to Arrays  
2.2 2D Arrays  
2.3 Prefix Sum & Difference Arrays  
2.4 Sliding Window on Arrays  
2.5 Kadane‚Äôs Algorithm (Max Subarray Sum)  
2.6 String Traversals  
2.7 StringBuilder & Character Array  
2.8 Palindromes  
2.9 Anagram Check  
2.10 Pattern Matching Basics  

---

## 3. üìö Recursion & Backtracking
3.1 What is Recursion?  
3.2 Factorial, Fibonacci  
3.3 Recursion Tree & Stack Tracing  
3.4 Subset Generation  
3.5 Permutations  
3.6 Backtracking: N-Queens  
3.7 Backtracking: Sudoku Solver  
3.8 Maze, Rat in a Maze  
3.9 Word Search  

---

## 4. üîÅ Searching & Sorting
4.1 Linear Search  
4.2 Binary Search  
4.3 First/Last Occurrence  
4.4 Lower/Upper Bound  
4.5 Bubble Sort  
4.6 Selection Sort  
4.7 Insertion Sort  
4.8 Merge Sort  
4.9 Quick Sort  
4.10 Counting Sort  
4.11 Search in Rotated Array  
4.12 Sorting with Comparator  

---

## 5. üß∫ Hashing & HashMap
5.1 HashMap and HashSet in Java  
5.2 Frequency Count  
5.3 Two Sum  
5.4 Longest Subarray with Sum K  
5.5 Group Anagrams  
5.6 Subarray Sum Equals K  
5.7 Isomorphic Strings  
5.8 HashMap for Pattern Matching  
5.9 Counting Distinct Elements  
5.10 Sliding Window with Hashing  

---

## 6. üé¢ Two Pointers & Sliding Window
6.1 Intro to Two Pointers  
6.2 Reverse Array  
6.3 Merge Two Sorted Arrays  
6.4 Pair Sum  
6.5 Three Sum  
6.6 Container With Most Water  
6.7 Sliding Window Maximum/Minimum  
6.8 Longest Substring Without Repeat  
6.9 Minimum Window Substring  
6.10 Smallest Subarray with Sum ‚â• K  

---

## 7. üß≠ Stack & Queue
7.1 Stack Using Array/List  
7.2 Stack Using Linked List  
7.3 Infix, Postfix, Prefix  
7.4 Valid Parentheses  
7.5 Next Greater Element  
7.6 Queue Using Array/List  
7.7 Circular Queue  
7.8 Deque (Double-Ended Queue)  
7.9 Monotonic Stack  
7.10 Queue with Two Stacks  

---

## 8. üå≥ Linked List
8.1 Singly Linked List  
8.2 Doubly Linked List  
8.3 Circular Linked List  
8.4 Reverse a Linked List  
8.5 Detect Cycle (Floyd‚Äôs Algo)  
8.6 Merge Two Sorted Lists  
8.7 Middle of Linked List  
8.8 Remove Nth Node from End  
8.9 Intersection Point of Two LLs  
8.10 LRU Cache  

---

## 9. üå≤ Trees & Binary Trees
9.1 Tree Terminologies  
9.2 Tree Traversals ‚Äì Inorder, Preorder, Postorder  
9.3 Level Order Traversal  
9.4 Height of Binary Tree  
9.5 Diameter of Binary Tree  
9.6 Left/Right View of Tree  
9.7 Balanced Binary Tree  
9.8 Mirror Binary Tree  
9.9 Tree to DLL  
9.10 Zigzag Level Order Traversal  

---

## 10. üåê Binary Search Tree (BST)
10.1 Search in BST  
10.2 Insert/Delete in BST  
10.3 Validate BST  
10.4 Lowest Common Ancestor  
10.5 Inorder Successor/Predecessor  
10.6 Kth Smallest/Largest in BST  
10.7 Convert BST to Greater Sum Tree  
10.8 BST to DLL  
10.9 Trim a BST  
10.10 BST Iterator  

---

## 11. üìà Heaps & PriorityQueue
11.1 Min Heap & Max Heap  
11.2 PriorityQueue in Java  
11.3 Heapify & Build Heap  
11.4 Heap Sort  
11.5 Kth Largest/Smallest Element  
11.6 Top K Frequent Elements  
11.7 Merge K Sorted Lists  
11.8 Median from Data Stream  
11.9 Sliding Window Maximum (Heap)  
11.10 Frequency Sort using Heap  

---

## 12. üåâ Graphs & Algorithms
12.1 Graph Representation (Matrix/List)  
12.2 BFS & DFS  
12.3 Detect Cycle in Graph (Undirected/Directed)  
12.4 Topological Sort  
12.5 Bipartite Graph  
12.6 Dijkstra‚Äôs Algorithm  
12.7 Bellman-Ford Algorithm  
12.8 Floyd-Warshall  
12.9 Prim‚Äôs Algorithm  
12.10 Kruskal‚Äôs Algorithm (MST)  
12.11 Union-Find (Disjoint Set)  
12.12 Number of Islands  
12.13 Clone Graph  

---

## 13. üß© Dynamic Programming (DP)
13.1 Recursion to DP Transition  
13.2 Memoization  
13.3 Tabulation  
13.4 0/1 Knapsack  
13.5 Subset Sum / Partition  
13.6 Longest Common Subsequence (LCS)  
13.7 Edit Distance  
13.8 Longest Increasing Subsequence  
13.9 DP on Grids (Unique Paths, Min Cost)  
13.10 Matrix Chain Multiplication  
13.11 DP on Trees  
13.12 DP on LIS  
13.13 Rod Cutting  
13.14 Egg Dropping Puzzle  
13.15 Digit DP  

---

## 14. üß† Greedy Algorithms
14.1 Greedy Strategy Basics  
14.2 Activity Selection  
14.3 Job Sequencing  
14.4 Fractional Knapsack  
14.5 Huffman Encoding  
14.6 Gas Station Problem  
14.7 Jump Game  
14.8 Minimum Platforms  
14.9 Greedy for Intervals  
14.10 Candy Distribution  

---

## 15. üß∞ Bit Manipulation
15.1 Binary Representation  
15.2 Count Set Bits  
15.3 Check Power of 2  
15.4 XOR Properties  
15.5 Single Number / Missing Number  
15.6 Bitmasking  
15.7 Subsets Using Bitmask  
15.8 AND, OR, XOR Range Problems  
15.9 Bitwise DP  
15.10 Flip Bits  

---

## 16. üß± Tries, Segment Trees & Others
16.1 Trie: Insert & Search  
16.2 Trie with Count/Prefix  
16.3 Word Dictionary (LeetCode)  
16.4 Segment Tree Basics  
16.5 Segment Tree for Range Sum  
16.6 Segment Tree for Range Min/Max  
16.7 Binary Indexed Tree (Fenwick Tree)  
16.8 Disjoint Set Union (DSU)  
16.9 Mo‚Äôs Algorithm  
16.10 Suffix Array and Suffix Tree  

---

## ‚úÖ Want a downloadable `.md` or GitHub repo with this structure?
Let me know and I‚Äôll set it up with:
- Topic folders
- Java template files
- README navigation
